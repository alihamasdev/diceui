---
title: Sortable
description: A drag and drop sortable component for reordering items.
links:
 doc: https://docs.dndkit.com/presets/sortable
 api: https://docs.dndkit.com/presets/sortable
---


<ComponentTabs name="sortable-demo">
```tsx
"use client";

import {
  Sortable,
  SortableContent,
  SortableItem,
  SortableOverlay,
} from "@/registry/default/ui/sortable";
import * as React from "react";

export default function SortableDemo() {
  const [tricks, setTricks] = React.useState([
    { id: "1", title: "The 900", points: 9000 },
    { id: "2", title: "Indy Backflip", points: 4000 },
    { id: "3", title: "Pizza Guy", points: 1500 },
    { id: "4", title: "360 Varial McTwist", points: 5000 },
    { id: "5", title: "Kickflip Backflip", points: 3000 },
    { id: "6", title: "FS 540", points: 4500 },
  ]);

  return (
    <Sortable value={tricks} onValueChange={setTricks} orientation="both">
      <SortableContent className="grid grid-cols-3 gap-2.5">
        {tricks.map((trick) => (
          <SortableItem key={trick.id} value={trick.id} asChild asGrip>
            <div className="flex aspect-video size-full flex-col items-center justify-center border border-zinc-500 p-6 text-center dark:border-zinc-800">
              <div className="font-medium">{trick.title}</div>
              <div className="text-sm text-zinc-500">{trick.points}</div>
            </div>
          </SortableItem>
        ))}
      </SortableContent>
      <SortableOverlay>
        {({ value }) => {
          const trick = tricks.find((trick) => trick.id === value);
          if (!trick) return null;

          return (
            <SortableItem value={trick.id} asChild>
              <div className="flex aspect-video size-full flex-col items-center justify-center border border-zinc-500 p-6 text-center dark:border-zinc-800">
                <div className="font-medium">{trick.title}</div>
                <div className="text-sm text-zinc-500">{trick.points}</div>
              </div>
            </SortableItem>
          );
        }}
      </SortableOverlay>
    </Sortable>
  );
}

```
</ComponentTabs>


## Installation


### CLI


```package-install
shadcn@latest add "https://diceui.com/r/sortable"

```


### Manual

<Steps>
  <Step>
     Install the following dependencies:

     ```package-install
     @dnd-kit/core @dnd-kit/modifiers @dnd-kit/sortable @dnd-kit/utilities
     ```
  </Step>
  <Step>
    Copy and paste the following code into your project.

    ```tsx
    "use client";

    import {
      DndContext,
      type DndContextProps,
      type DragEndEvent,
      DragOverlay,
      type DraggableSyntheticListeners,
      type DropAnimation,
      KeyboardSensor,
      MouseSensor,
      TouchSensor,
      type UniqueIdentifier,
      closestCenter,
      closestCorners,
      defaultDropAnimationSideEffects,
      useSensor,
      useSensors,
    } from "@dnd-kit/core";
    import {
      restrictToHorizontalAxis,
      restrictToParentElement,
      restrictToVerticalAxis,
    } from "@dnd-kit/modifiers";
    import {
      SortableContext,
      type SortableContextProps,
      arrayMove,
      horizontalListSortingStrategy,
      sortableKeyboardCoordinates,
      useSortable,
      verticalListSortingStrategy,
    } from "@dnd-kit/sortable";
    import { CSS } from "@dnd-kit/utilities";
    import { Slot, type SlotProps } from "@radix-ui/react-slot";
    import * as React from "react";

    import { Button, type ButtonProps } from "@/components/ui/button";
    import { composeRefs } from "@/lib/compose-refs";
    import { cn, composeEventHandlers } from "@/lib/utils";

    const orientationConfig = {
      vertical: {
        modifiers: [restrictToVerticalAxis, restrictToParentElement],
        strategy: verticalListSortingStrategy,
        collisionDetection: closestCenter,
      },
      horizontal: {
        modifiers: [restrictToHorizontalAxis, restrictToParentElement],
        strategy: horizontalListSortingStrategy,
        collisionDetection: closestCenter,
      },
      both: {
        modifiers: [restrictToParentElement],
        strategy: undefined,
        collisionDetection: closestCorners,
      },
    };

    const SORTABLE_NAME = "Sortable";
    const SORTABLE_CONTENT_NAME = "SortableContent";
    const SORTABLE_ITEM_NAME = "SortableItem";
    const SORTABLE_ITEM_GRIP_NAME = "SortableItemGrip";
    const SORTABLE_OVERLAY_NAME = "SortableOverlay";

    const SORTABLE_ERROR = {
      root: `${SORTABLE_NAME} components must be within ${SORTABLE_NAME}`,
      content: `${SORTABLE_CONTENT_NAME} must be within ${SORTABLE_NAME}`,
      item: `${SORTABLE_ITEM_NAME} must be within ${SORTABLE_CONTENT_NAME}`,
      grip: `${SORTABLE_ITEM_GRIP_NAME} must be within ${SORTABLE_ITEM_NAME}`,
      overlay: `${SORTABLE_OVERLAY_NAME} must be within ${SORTABLE_NAME}`,
    } as const;

    type UniqueItem = { id: UniqueIdentifier };

    interface SortableProviderContext<T extends UniqueItem> {
      id: string;
      items: T[];
      modifiers: DndContextProps["modifiers"];
      strategy: SortableContextProps["strategy"];
      activeId: UniqueIdentifier | null;
      setActiveId: (id: UniqueIdentifier | null) => void;
      flatCursor: boolean;
    }

    const SortableRoot = React.createContext<SortableProviderContext<{
      id: UniqueIdentifier;
    }> | null>(null);
    SortableRoot.displayName = SORTABLE_NAME;

    function useSortableRoot() {
      const context = React.useContext(SortableRoot);
      if (!context) {
        throw new Error(SORTABLE_ERROR.root);
      }
      return context;
    }

    interface SortableProps<T extends UniqueItem> extends DndContextProps {
      value: T[];
      onValueChange?: (items: T[]) => void;
      onMove?: (event: DragEndEvent) => void;
      collisionDetection?: DndContextProps["collisionDetection"];
      modifiers?: DndContextProps["modifiers"];
      sensors?: DndContextProps["sensors"];
      orientation?: "vertical" | "horizontal" | "both";
      flatCursor?: boolean;
    }

    function Sortable<T extends UniqueItem>(props: SortableProps<T>) {
      const {
        value,
        onValueChange,
        collisionDetection,
        modifiers,
        sensors: sensorsProp,
        onMove,
        orientation = "vertical",
        flatCursor = false,
        ...sortableProps
      } = props;
      const id = React.useId();
      const [activeId, setActiveId] = React.useState<UniqueIdentifier | null>(null);
      const sensors = useSensors(
        useSensor(MouseSensor),
        useSensor(TouchSensor),
        useSensor(KeyboardSensor, {
          coordinateGetter: sortableKeyboardCoordinates,
        }),
      );
      const config = React.useMemo(
        () => orientationConfig[orientation],
        [orientation],
      );
      const contextValue = React.useMemo(
        () => ({
          id,
          items: value,
          modifiers: modifiers ?? config.modifiers,
          strategy: config.strategy,
          activeId,
          setActiveId,
          flatCursor,
        }),
        [
          id,
          value,
          modifiers,
          config.modifiers,
          config.strategy,
          activeId,
          flatCursor,
        ],
      );

      return (
        <SortableRoot.Provider value={contextValue}>
          <DndContext
            id={id}
            modifiers={modifiers ?? config.modifiers}
            sensors={sensorsProp ?? sensors}
            onDragStart={composeEventHandlers(
              sortableProps.onDragStart,
              ({ active }) => setActiveId(active.id),
            )}
            onDragEnd={composeEventHandlers(
              sortableProps.onDragEnd,
              ({ active, over, activatorEvent, collisions, delta }) => {
                if (over && active.id !== over?.id) {
                  const activeIndex = value.findIndex(
                    (item) => item.id === active.id,
                  );
                  const overIndex = value.findIndex((item) => item.id === over.id);

                  if (onMove) {
                    onMove({ active, over, activatorEvent, collisions, delta });
                  } else {
                    onValueChange?.(arrayMove(value, activeIndex, overIndex));
                  }
                }
                setActiveId(null);
              },
            )}
            onDragCancel={composeEventHandlers(sortableProps.onDragCancel, () =>
              setActiveId(null),
            )}
            collisionDetection={collisionDetection ?? config.collisionDetection}
            accessibility={{
              announcements: {
                onDragStart({ active }) {
                  return `Picked up sortable item ${active.id}. Use arrow keys to move, space to drop.`;
                },
                onDragOver({ active, over }) {
                  if (over) {
                    return `Sortable item ${active.id} was moved over position ${over.id}`;
                  }
                  return `Sortable item ${active.id} is no longer over a droppable area`;
                },
                onDragEnd({ active, over }) {
                  if (over) {
                    return `Sortable item ${active.id} was dropped over position ${over.id}`;
                  }
                  return `Sortable item ${active.id} was dropped`;
                },
                onDragCancel({ active }) {
                  return `Sorting was cancelled. Sortable item ${active.id} was dropped.`;
                },
                onDragMove({ active, over }) {
                  if (over) {
                    return `Sortable item ${active.id} was moved over position ${over.id}`;
                  }
                  return `Sortable item ${active.id} is no longer over a droppable area`;
                },
              },
              ...sortableProps.accessibility,
            }}
            {...sortableProps}
          />
        </SortableRoot.Provider>
      );
    }

    const SortableContentContext = React.createContext<boolean>(false);
    SortableContentContext.displayName = SORTABLE_CONTENT_NAME;

    interface SortableContentProps extends SlotProps {
      strategy?: SortableContextProps["strategy"];
      children: React.ReactNode;
      asChild?: boolean;
    }

    const SortableContent = React.forwardRef<HTMLDivElement, SortableContentProps>(
      (props, ref) => {
        const {
          strategy: strategyProp,
          children,
          asChild,
          ...contentProps
        } = props;
        const context = React.useContext(SortableRoot);
        if (!context) {
          throw new Error(SORTABLE_ERROR.content);
        }

        const ContentSlot = asChild ? Slot : "div";

        return (
          <SortableContentContext.Provider value={true}>
            <SortableContext
              items={context.items}
              strategy={strategyProp ?? context.strategy}
            >
              <ContentSlot ref={ref} {...contentProps}>
                {children}
              </ContentSlot>
            </SortableContext>
          </SortableContentContext.Provider>
        );
      },
    );
    SortableContent.displayName = SORTABLE_CONTENT_NAME;

    const SortableOverlayContext = React.createContext(false);
    SortableOverlayContext.displayName = SORTABLE_OVERLAY_NAME;

    const dropAnimation: DropAnimation = {
      sideEffects: defaultDropAnimationSideEffects({
        styles: {
          active: {
            opacity: "0.4",
          },
        },
      }),
    };

    interface SortableOverlayProps
      extends Omit<React.ComponentPropsWithoutRef<typeof DragOverlay>, "children"> {
      children?:
        | ((params: { value: UniqueIdentifier }) => React.ReactNode)
        | React.ReactNode;
    }

    function SortableOverlay(props: SortableOverlayProps) {
      const { dropAnimation: dropAnimationProp, children, ...overlayProps } = props;
      const context = React.useContext(SortableRoot);
      if (!context) {
        throw new Error(SORTABLE_ERROR.overlay);
      }

      const activeItem = context.items.find((item) => item.id === context.activeId);

      return (
        <DragOverlay
          modifiers={context.modifiers}
          dropAnimation={dropAnimationProp ?? dropAnimation}
          className={cn(!context.flatCursor && "cursor-grabbing")}
          {...overlayProps}
        >
          <SortableOverlayContext.Provider value={true}>
            {activeItem ? (
              typeof children === "function" ? (
                children({ value: activeItem.id })
              ) : (
                <SortableItem value={activeItem.id} asChild>
                  {children}
                </SortableItem>
              )
            ) : null}
          </SortableOverlayContext.Provider>
        </DragOverlay>
      );
    }

    interface SortableItemContextProps {
      id: string;
      attributes: React.HTMLAttributes<HTMLElement>;
      listeners: DraggableSyntheticListeners | undefined;
      isDragging?: boolean;
    }

    const SortableItemContext = React.createContext<SortableItemContextProps>({
      id: "",
      attributes: {},
      listeners: undefined,
      isDragging: false,
    });
    SortableItemContext.displayName = SORTABLE_ITEM_NAME;

    interface SortableItemProps extends SlotProps {
      value: UniqueIdentifier;
      asGrip?: boolean;
      asChild?: boolean;
    }

    const SortableItem = React.forwardRef<HTMLDivElement, SortableItemProps>(
      (props, ref) => {
        const inSortableContent = React.useContext(SortableContentContext);
        const inSortableOverlay = React.useContext(SortableOverlayContext);

        if (!inSortableContent && !inSortableOverlay) {
          throw new Error(SORTABLE_ERROR.item);
        }

        const {
          value,
          style: styleProp,
          asGrip,
          asChild,
          className,
          ...itemProps
        } = props;
        const context = useSortableRoot();
        const id = React.useId();
        const {
          attributes,
          listeners,
          setNodeRef,
          transform,
          transition,
          isDragging,
        } = useSortable({ id: value });

        const style: React.CSSProperties = {
          opacity: isDragging ? 0.5 : 1,
          transform: CSS.Translate.toString(transform),
          transition,
          ...styleProp,
        };

        const ItemSlot = asChild ? Slot : "div";

        const itemContext = React.useMemo<SortableItemContextProps>(
          () => ({
            id,
            attributes,
            listeners,
            isDragging,
          }),
          [id, attributes, listeners, isDragging],
        );

        return (
          <SortableItemContext.Provider value={itemContext}>
            <ItemSlot
              id={id}
              ref={composeRefs(ref, (node) => setNodeRef(node))}
              data-sortable-item=""
              data-dragging={isDragging ? "" : undefined}
              className={cn(
                {
                  "touch-none select-none": asGrip,
                  "cursor-default": context.flatCursor,
                  "data-[dragging]:cursor-grabbing": !context.flatCursor,
                  "cursor-grab": !isDragging && asGrip && !context.flatCursor,
                },
                className,
              )}
              style={style}
              {...(asGrip ? attributes : {})}
              {...(asGrip ? listeners : {})}
              {...itemProps}
            />
          </SortableItemContext.Provider>
        );
      },
    );
    SortableItem.displayName = SORTABLE_ITEM_NAME;

    interface SortableItemGripProps extends ButtonProps {}

    const SortableItemGrip = React.forwardRef<
      HTMLButtonElement,
      SortableItemGripProps
    >((props, ref) => {
      const itemContext = React.useContext(SortableItemContext);
      if (!itemContext) {
        throw new Error(SORTABLE_ERROR.grip);
      }

      const { className, ...dragHandleProps } = props;
      const context = useSortableRoot();

      return (
        <Button
          ref={ref}
          aria-controls={itemContext.id}
          data-dragging={itemContext.isDragging ? "" : undefined}
          className={cn(
            "touch-none select-none",
            context.flatCursor
              ? "cursor-default"
              : "cursor-grab data-[dragging]:cursor-grabbing",
            className,
          )}
          {...itemContext.attributes}
          {...itemContext.listeners}
          {...dragHandleProps}
        />
      );
    });
    SortableItemGrip.displayName = "SortableItemGrip";

    export {
      Sortable,
      SortableContent,
      SortableItem,
      SortableItemGrip,
      SortableOverlay,
    };
    ```
  </Step>
</Steps>



## Examples

### With Grip

<ComponentTabs name="sortable-grip-demo">
```tsx
"use client";

import { Skeleton } from "@/components/ui/skeleton";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Sortable,
  SortableContent,
  SortableItem,
  SortableItemGrip,
  SortableOverlay,
} from "@/registry/default/ui/sortable";
import { GripVertical } from "lucide-react";
import * as React from "react";

export default function SortableGripDemo() {
  const [tricks, setTricks] = React.useState([
    { id: "1", title: "The 900", difficulty: "Expert", points: 9000 },
    { id: "2", title: "Indy Backflip", difficulty: "Advanced", points: 4000 },
    { id: "3", title: "Pizza Guy", difficulty: "Intermediate", points: 1500 },
    {
      id: "4",
      title: "360 Varial McTwist",
      difficulty: "Expert",
      points: 5000,
    },
  ]);

  return (
    <Sortable value={tricks} onValueChange={setTricks}>
      <Table className="rounded-none border">
        <TableHeader>
          <TableRow className="bg-accent/50">
            <TableHead className="w-[50px] bg-transparent" />
            <TableHead className="bg-transparent">Trick</TableHead>
            <TableHead className="bg-transparent">Difficulty</TableHead>
            <TableHead className="bg-transparent text-right">Points</TableHead>
          </TableRow>
        </TableHeader>
        <SortableContent asChild>
          <TableBody>
            {tricks.map((trick) => (
              <SortableItem key={trick.id} value={trick.id} asChild>
                <TableRow>
                  <TableCell className="w-[50px]">
                    <SortableItemGrip
                      variant="ghost"
                      size="icon"
                      className="size-8"
                    >
                      <GripVertical className="h-4 w-4" />
                    </SortableItemGrip>
                  </TableCell>
                  <TableCell className="font-medium">{trick.title}</TableCell>
                  <TableCell className="text-muted-foreground">
                    {trick.difficulty}
                  </TableCell>
                  <TableCell className="text-right text-muted-foreground">
                    {trick.points}
                  </TableCell>
                </TableRow>
              </SortableItem>
            ))}
          </TableBody>
        </SortableContent>
      </Table>
      <SortableOverlay>
        <Skeleton className="size-full rounded-none" />
      </SortableOverlay>
    </Sortable>
  );
}
```
</ComponentTabs>


## API Reference

### Sortable

The main container component for sortable functionality.

<AutoTypeTable
  path="./types/docs/sortable.ts"
  name="SortableProps"
/>

<DataAttributesTable
  attributes={[
    {
      title: "[data-dragging]",
      value: "Present when an item is being dragged",
    },
  ]}
/>

### SortableContent

Container for sortable items. Multiple `SortableContent` components can be used within a `Sortable` component.

<AutoTypeTable
  path="./types/docs/sortable.ts"
  name="SortableContentProps"
/>

### SortableItem

Individual sortable item component.

<AutoTypeTable
  path="./types/docs/sortable.ts"
  name="SortableItemProps"
/>

<DataAttributesTable
  attributes={[
    {
      title: "[data-dragging]",
      value: "Present when the item is being dragged",
    },
    {
      title: "[data-sortable-item]",
      value: "Present on all sortable items",
    },
  ]}
/>

### SortableItemGrip

A button component that acts as a drag handle for sortable items.

#### Props

<AutoTypeTable
  path="./types/docs/sortable.ts"
  name="SortableItemGripProps"
/>

<DataAttributesTable
  attributes={[
    {
      title: "[data-dragging]",
      value: "Present when the parent sortable item is being dragged",
    }
  ]}
/>

#### CSS

The component extends the base Button component and adds the following styles:

- `cursor-grab` when not dragging (unless `disableGrabCursor` is true)
- `cursor-grabbing` when dragging (unless `disableGrabCursor` is true)
- `cursor-default` when `disableGrabCursor` is true

#### Accessibility

- Has `aria-controls` pointing to the parent sortable item's ID
- Inherits ARIA attributes from the sortable context for drag and drop operations
- Can be activated using keyboard navigation

## Accessibility

### Keyboard Interactions

<KeyboardShortcutsTable
  shortcuts={[
    {
      keys: ["Enter", "Space"],
      description: "Picks up the sortable item for reordering.",
    },
    {
      keys: ["↑", "↓"],
      description: "Moves the sortable item up or down in vertical orientation.",
    },
    {
      keys: ["←", "→"],
      description: "Moves the sortable item left or right in horizontal orientation",
    },
    {
      keys: ["Enter", "Space"],
      description: "Drops the sortable item in its new position.",
    },
    {
      keys: ["Esc"],
      description: "Cancels the sort operation and returns the item to its original position.",
    },
  ]}
/>

### ARIA Roles

- The sortable container has `role="list"`
- Each sortable item has `role="listitem"`
- Drag handles have `aria-label="Drag handle"`
- Live announcements are made during drag and drop operations

### Focus Management

- Drag handles are focusable and can be activated using the keyboard
- Focus is maintained on the dragged item throughout the sorting operation
- Focus returns to the drag handle when sorting is complete
