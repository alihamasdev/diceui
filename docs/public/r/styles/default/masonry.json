{
  "name": "masonry",
  "type": "registry:ui",
  "dependencies": [
    "@diceui/masonry",
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/masonry.tsx",
      "content": "\"use client\";\n\nimport { useComposedRefs } from \"@/lib/composition\";\nimport { cn } from \"@/lib/utils\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nconst DATA_LINE_BREAK_ATTR = \"data-masonry-line-break\";\nconst DATA_ITEM_ATTR = \"data-masonry-item\";\n\nconst ROOT_NAME = \"MasonryRoot\";\nconst ITEM_NAME = \"MasonryItem\";\n\nconst MASONRY_ERROR = {\n  [ROOT_NAME]: `\\`${ROOT_NAME}\\` components must be within \\`${ROOT_NAME}\\``,\n  [ITEM_NAME]: `\\`${ITEM_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n} as const;\n\ninterface MasonryContextValue {\n  mounted: boolean;\n}\n\nconst MasonryContext = React.createContext<MasonryContextValue | null>(null);\nMasonryContext.displayName = ROOT_NAME;\n\nfunction useMasonryContext(name: keyof typeof MASONRY_ERROR) {\n  const context = React.useContext(MasonryContext);\n  if (!context) {\n    throw new Error(MASONRY_ERROR[name]);\n  }\n  return context;\n}\n\nconst TAILWIND_BREAKPOINTS = {\n  initial: 0,\n  sm: 640,\n  md: 768,\n  lg: 1024,\n  xl: 1280,\n  \"2xl\": 1536,\n} as const;\n\ntype TailwindBreakpoint = keyof typeof TAILWIND_BREAKPOINTS;\ntype BreakpointValue = TailwindBreakpoint | number;\ntype ResponsiveObject = Partial<Record<BreakpointValue, number>>;\ntype ResponsiveValue = number | ResponsiveObject;\n\ninterface ItemMeasurements {\n  height: number;\n  marginTop: number;\n  marginBottom: number;\n  width: number;\n}\n\nconst itemCache = new WeakMap<HTMLElement, ItemMeasurements>();\n\nfunction parseBreakpoint(breakpoint: BreakpointValue): number {\n  if (typeof breakpoint === \"number\") return breakpoint;\n  return breakpoint in TAILWIND_BREAKPOINTS\n    ? TAILWIND_BREAKPOINTS[breakpoint]\n    : Number(breakpoint);\n}\n\nfunction getInitialValue(value: ResponsiveValue, defaultValue: number): number {\n  if (typeof value === \"number\") return value;\n  if (\"initial\" in value) return value.initial ?? defaultValue;\n\n  const breakpoints = Object.entries(value)\n    .map(([key, val]) => ({\n      breakpoint: parseBreakpoint(key as BreakpointValue),\n      value: val ?? defaultValue,\n    }))\n    .sort((a, b) => a.breakpoint - b.breakpoint);\n\n  return breakpoints[0]?.value ?? defaultValue;\n}\n\nfunction useResponsiveValue({\n  value,\n  defaultValue,\n  mounted,\n}: {\n  value: ResponsiveValue;\n  defaultValue: number;\n  mounted: boolean;\n}): number {\n  const initialValue = React.useMemo(\n    () => getInitialValue(value, defaultValue),\n    [value, defaultValue],\n  );\n  const [currentValue, setCurrentValue] = React.useState(initialValue);\n\n  const onResize = React.useCallback(() => {\n    if (!mounted) return;\n    if (typeof value === \"number\") {\n      setCurrentValue(value);\n      return;\n    }\n\n    const width = window.innerWidth;\n    const breakpoints = Object.entries(value)\n      .map(([key, val]) => ({\n        breakpoint:\n          key === \"initial\" ? 0 : parseBreakpoint(key as BreakpointValue),\n        value: val ?? defaultValue,\n      }))\n      .sort((a, b) => b.breakpoint - a.breakpoint);\n\n    const newValue =\n      breakpoints.find(({ breakpoint }) => width >= breakpoint)?.value ??\n      defaultValue;\n    setCurrentValue(newValue);\n  }, [value, defaultValue, mounted]);\n\n  React.useEffect(() => {\n    if (!mounted) return;\n\n    function debounce<T extends (...args: unknown[]) => unknown>(\n      fn: T,\n      delay: number,\n    ): (...args: Parameters<T>) => void {\n      let timeoutId: ReturnType<typeof setTimeout>;\n      return (...args: Parameters<T>) => {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => fn(...args), delay);\n      };\n    }\n\n    const debouncedResize = debounce(onResize, 100);\n    window.addEventListener(\"resize\", debouncedResize);\n    return () => window.removeEventListener(\"resize\", debouncedResize);\n  }, [onResize, mounted]);\n\n  return currentValue;\n}\n\nconst useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\n\nfunction getMasonryItemMeasurements(\n  element: HTMLElement,\n  gap: number,\n): ItemMeasurements {\n  const cached = itemCache.get(element);\n  if (cached) return cached;\n\n  const style = window.getComputedStyle(element);\n  const measurements = {\n    height: element.offsetHeight,\n    marginTop: Number.parseFloat(style.marginTop) || gap / 2,\n    marginBottom: Number.parseFloat(style.marginBottom) || gap / 2,\n    width: element.offsetWidth,\n  };\n\n  itemCache.set(element, measurements);\n  return measurements;\n}\n\ninterface MasonryProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  columnCount?: ResponsiveValue;\n  gap?: ResponsiveValue;\n  linear?: boolean;\n  asChild?: boolean;\n}\n\nconst Masonry = React.memo(\n  React.forwardRef<HTMLDivElement, MasonryProps>((props, forwardedRef) => {\n    const {\n      children,\n      columnCount = 4,\n      gap = 16,\n      linear = false,\n      asChild,\n      className,\n      style,\n      ...rootProps\n    } = props;\n\n    const [maxColumnHeight, setMaxColumnHeight] = React.useState<number>();\n    const collectionRef = React.useRef<HTMLDivElement>(null);\n    const composedRef = useComposedRefs(forwardedRef, collectionRef);\n    const layoutTimeoutRef = React.useRef<number | null>(null);\n\n    const [mounted, setMounted] = React.useState(false);\n    React.useLayoutEffect(() => {\n      setMounted(true);\n    }, []);\n\n    const currentColumnCount = useResponsiveValue({\n      value: columnCount,\n      defaultValue: 4,\n      mounted,\n    });\n    const currentGap = useResponsiveValue({\n      value: gap,\n      defaultValue: 16,\n      mounted,\n    });\n    const lineBreakCount = currentColumnCount > 0 ? currentColumnCount - 1 : 0;\n\n    const calculateLayout = React.useCallback(() => {\n      if (!collectionRef.current || !mounted) return;\n\n      const items = Array.from(\n        collectionRef.current.querySelectorAll(`[${DATA_ITEM_ATTR}]`),\n      ).filter((child): child is HTMLElement => child instanceof HTMLElement);\n\n      const columnHeights = new Array(currentColumnCount).fill(0);\n      let skip = false;\n\n      // Reset styles and cache\n      for (const item of items) {\n        itemCache.delete(item);\n        Object.assign(item.style, {\n          position: \"absolute\",\n          width: `calc(${100 / currentColumnCount}% - ${\n            (currentGap * (currentColumnCount - 1)) / currentColumnCount\n          }px)`,\n          margin: `${currentGap / 2}px`,\n        });\n      }\n\n      // Position items\n      for (const item of items) {\n        if (skip) continue;\n\n        const measurements = getMasonryItemMeasurements(item, currentGap);\n        const itemHeight =\n          measurements.height +\n          measurements.marginTop +\n          measurements.marginBottom;\n\n        if (\n          itemHeight === 0 ||\n          Array.from(item.getElementsByTagName(\"img\")).some(\n            (img) => img.clientHeight === 0,\n          )\n        ) {\n          skip = true;\n          continue;\n        }\n\n        if (linear) {\n          const columnIndex = columnHeights.indexOf(Math.min(...columnHeights));\n          const yPos = columnHeights[columnIndex];\n          Object.assign(item.style, {\n            top: `${yPos}px`,\n            left: `${columnIndex * (measurements.width + currentGap)}px`,\n          });\n          columnHeights[columnIndex] = yPos + itemHeight;\n        } else {\n          const minColumnIndex = columnHeights.indexOf(\n            Math.min(...columnHeights),\n          );\n          const xPos = minColumnIndex * (measurements.width + currentGap);\n          const yPos = columnHeights[minColumnIndex];\n\n          Object.assign(item.style, {\n            top: `${yPos}px`,\n            left: `${xPos}px`,\n          });\n          columnHeights[minColumnIndex] = yPos + itemHeight;\n        }\n      }\n\n      if (!skip) {\n        ReactDOM.flushSync(() => {\n          const maxHeight = Math.max(...columnHeights);\n          setMaxColumnHeight(maxHeight > 0 ? maxHeight : undefined);\n        });\n      }\n    }, [currentColumnCount, currentGap, linear, mounted]);\n\n    useIsomorphicLayoutEffect(() => {\n      if (typeof ResizeObserver === \"undefined\") return;\n\n      const resizeObserver = new ResizeObserver(() => {\n        if (layoutTimeoutRef.current) {\n          cancelAnimationFrame(layoutTimeoutRef.current);\n        }\n        layoutTimeoutRef.current = requestAnimationFrame(calculateLayout);\n      });\n\n      const content = collectionRef.current;\n      if (content) {\n        resizeObserver.observe(content);\n        const items = content.querySelectorAll(`[${DATA_ITEM_ATTR}]`);\n        for (const child of items) {\n          resizeObserver.observe(child);\n        }\n      }\n\n      return () => {\n        if (layoutTimeoutRef.current) {\n          cancelAnimationFrame(layoutTimeoutRef.current);\n        }\n        resizeObserver.disconnect();\n      };\n    }, [calculateLayout]);\n\n    const lineBreaks = React.useMemo(() => {\n      if (!mounted) return null;\n\n      return Array.from({ length: lineBreakCount }, (_, i) => {\n        const key = `line-break-${currentColumnCount}-${i}`;\n\n        return (\n          <span\n            key={key}\n            {...{ [DATA_LINE_BREAK_ATTR]: \"\" }}\n            style={{\n              flexBasis: \"100%\",\n              width: 0,\n              margin: 0,\n              padding: 0,\n              order: i + 1,\n            }}\n          />\n        );\n      });\n    }, [lineBreakCount, mounted, currentColumnCount]);\n\n    const initialGridStyle = React.useMemo(\n      () => ({\n        display: mounted ? \"block\" : \"grid\",\n        gridTemplateColumns: !mounted\n          ? `repeat(${getInitialValue(columnCount, 4)}, 1fr)`\n          : undefined,\n        gap: !mounted ? `${getInitialValue(gap, 16)}px` : undefined,\n      }),\n      [columnCount, gap, mounted],\n    );\n\n    const RootSlot = asChild ? Slot : \"div\";\n\n    const contextValue = React.useMemo(\n      () => ({\n        mounted,\n      }),\n      [mounted],\n    );\n\n    return (\n      <MasonryContext.Provider value={contextValue}>\n        <RootSlot\n          {...rootProps}\n          ref={composedRef}\n          className={cn(\"relative mx-auto w-full\", className)}\n          style={{\n            ...style,\n            ...initialGridStyle,\n            height:\n              mounted && maxColumnHeight ? `${maxColumnHeight}px` : \"auto\",\n            minHeight: \"0px\",\n            width: mounted ? `calc(100% - ${currentGap}px)` : \"100%\",\n            marginLeft: mounted ? `${currentGap / 2}px` : undefined,\n            marginRight: mounted ? `${currentGap / 2}px` : undefined,\n          }}\n        >\n          {children}\n          {lineBreaks}\n        </RootSlot>\n      </MasonryContext.Provider>\n    );\n  }),\n);\n\nMasonry.displayName = ROOT_NAME;\n\ninterface MasonryItemProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  asChild?: boolean;\n  fallback?: React.ReactNode;\n}\n\nconst MasonryItem = React.forwardRef<HTMLDivElement, MasonryItemProps>(\n  (props, forwardedRef) => {\n    const { asChild, fallback, ...itemProps } = props;\n\n    const context = useMasonryContext(ITEM_NAME);\n\n    if (!context.mounted && fallback) {\n      return fallback;\n    }\n\n    const ItemSlot = asChild ? Slot : \"div\";\n\n    return (\n      <ItemSlot\n        {...{ [DATA_ITEM_ATTR]: \"\" }}\n        {...itemProps}\n        ref={forwardedRef}\n      />\n    );\n  },\n);\n\nMasonryItem.displayName = ITEM_NAME;\n\nconst Root = Masonry;\nconst Item = MasonryItem;\n\nexport {\n  Item,\n  Masonry,\n  MasonryItem,\n  //\n  Root,\n};\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}