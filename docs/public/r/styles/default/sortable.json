{
  "name": "sortable",
  "type": "registry:ui",
  "dependencies": [
    "@dnd-kit/core",
    "@dnd-kit/modifiers",
    "@dnd-kit/sortable",
    "@dnd-kit/utilities",
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/sortable.tsx",
      "content": "\"use client\";\n\nimport {\n  DndContext,\n  type DndContextProps,\n  type DragEndEvent,\n  DragOverlay,\n  type DraggableSyntheticListeners,\n  type DropAnimation,\n  KeyboardSensor,\n  MouseSensor,\n  TouchSensor,\n  type UniqueIdentifier,\n  closestCenter,\n  closestCorners,\n  defaultDropAnimationSideEffects,\n  useSensor,\n  useSensors,\n} from \"@dnd-kit/core\";\nimport {\n  restrictToHorizontalAxis,\n  restrictToParentElement,\n  restrictToVerticalAxis,\n} from \"@dnd-kit/modifiers\";\nimport {\n  SortableContext,\n  type SortableContextProps,\n  arrayMove,\n  horizontalListSortingStrategy,\n  sortableKeyboardCoordinates,\n  useSortable,\n  verticalListSortingStrategy,\n} from \"@dnd-kit/sortable\";\nimport { CSS } from \"@dnd-kit/utilities\";\nimport { Slot, type SlotProps } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\n\nimport { composeEventHandlers, useComposedRefs } from \"@/lib/composition\";\nimport { cn } from \"@/lib/utils\";\nimport * as ReactDOM from \"react-dom\";\n\nconst orientationConfig = {\n  vertical: {\n    modifiers: [restrictToVerticalAxis, restrictToParentElement],\n    strategy: verticalListSortingStrategy,\n    collisionDetection: closestCenter,\n  },\n  horizontal: {\n    modifiers: [restrictToHorizontalAxis, restrictToParentElement],\n    strategy: horizontalListSortingStrategy,\n    collisionDetection: closestCenter,\n  },\n  mixed: {\n    modifiers: [restrictToParentElement],\n    strategy: undefined,\n    collisionDetection: closestCorners,\n  },\n};\n\nconst ROOT_NAME = \"Sortable\";\nconst CONTENT_NAME = \"SortableContent\";\nconst ITEM_NAME = \"SortableItem\";\nconst ITEM_HANDLE_NAME = \"SortableItemHandle\";\nconst OVERLAY_NAME = \"SortableOverlay\";\n\nconst SORTABLE_ERROR = {\n  root: `${ROOT_NAME} components must be within ${ROOT_NAME}`,\n  content: `${CONTENT_NAME} must be within ${ROOT_NAME}`,\n  item: `${ITEM_NAME} must be within ${CONTENT_NAME}`,\n  itemHandle: `${ITEM_HANDLE_NAME} must be within ${ITEM_NAME}`,\n  overlay: `${OVERLAY_NAME} must be within ${ROOT_NAME}`,\n} as const;\n\ninterface SortableRootContextValue<T> {\n  id: string;\n  items: T[];\n  modifiers: DndContextProps[\"modifiers\"];\n  strategy: SortableContextProps[\"strategy\"];\n  activeId: UniqueIdentifier | null;\n  setActiveId: (id: UniqueIdentifier | null) => void;\n  getItemValue: (item: T) => UniqueIdentifier;\n  flatCursor: boolean;\n}\n\nconst SortableRootContext =\n  React.createContext<SortableRootContextValue<unknown> | null>(null);\nSortableRootContext.displayName = ROOT_NAME;\n\nfunction useSortableContext(name: keyof typeof SORTABLE_ERROR) {\n  const context = React.useContext(SortableRootContext);\n  if (!context) {\n    throw new Error(SORTABLE_ERROR[name]);\n  }\n  return context;\n}\n\ninterface GetItemValue<T> {\n  /**\n   * Callback that returns a unique identifier for each sortable item. Required for array of objects.\n   * @example getItemValue={(item) => item.id}\n   */\n  getItemValue: (item: T) => UniqueIdentifier;\n}\n\ntype SortableProps<T> = DndContextProps & {\n  value: T[];\n  onValueChange?: (items: T[]) => void;\n  onMove?: (event: DragEndEvent) => void;\n  strategy?: SortableContextProps[\"strategy\"];\n  orientation?: \"vertical\" | \"horizontal\" | \"mixed\";\n  flatCursor?: boolean;\n} & (T extends object ? GetItemValue<T> : Partial<GetItemValue<T>>);\n\nfunction Sortable<T>(props: SortableProps<T>) {\n  const {\n    id = React.useId(),\n    value,\n    onValueChange,\n    collisionDetection,\n    modifiers,\n    strategy,\n    sensors: sensorsProp,\n    onMove,\n    orientation = \"vertical\",\n    flatCursor = false,\n    getItemValue: getItemValueProp,\n    ...sortableProps\n  } = props;\n  const [activeId, setActiveId] = React.useState<UniqueIdentifier | null>(null);\n  const sensors = useSensors(\n    useSensor(MouseSensor),\n    useSensor(TouchSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    }),\n  );\n  const config = React.useMemo(\n    () => orientationConfig[orientation],\n    [orientation],\n  );\n  const getItemValue = React.useCallback(\n    (item: T): UniqueIdentifier => {\n      if (typeof item === \"object\" && !getItemValueProp) {\n        throw new Error(\n          \"getItemValue is required when using array of objects.\",\n        );\n      }\n      return getItemValueProp\n        ? getItemValueProp(item)\n        : (item as UniqueIdentifier);\n    },\n    [getItemValueProp],\n  );\n\n  const onDragEnd = React.useCallback(\n    (event: DragEndEvent) => {\n      const { active, over } = event;\n      if (over && active.id !== over?.id) {\n        const activeIndex = value.findIndex(\n          (item) => getItemValue(item) === active.id,\n        );\n        const overIndex = value.findIndex(\n          (item) => getItemValue(item) === over.id,\n        );\n\n        if (onMove) {\n          onMove(event);\n        } else {\n          onValueChange?.(arrayMove(value, activeIndex, overIndex));\n        }\n      }\n      setActiveId(null);\n    },\n    [value, onValueChange, onMove, getItemValue],\n  );\n\n  const contextValue = React.useMemo(\n    () => ({\n      id,\n      items: value,\n      modifiers: modifiers ?? config.modifiers,\n      strategy: strategy ?? config.strategy,\n      activeId,\n      setActiveId,\n      getItemValue,\n      flatCursor,\n    }),\n    [\n      id,\n      value,\n      modifiers,\n      strategy,\n      config.modifiers,\n      config.strategy,\n      activeId,\n      getItemValue,\n      flatCursor,\n    ],\n  );\n\n  return (\n    <SortableRootContext.Provider\n      value={contextValue as SortableRootContextValue<unknown>}\n    >\n      <DndContext\n        id={id}\n        modifiers={modifiers ?? config.modifiers}\n        sensors={sensorsProp ?? sensors}\n        onDragStart={composeEventHandlers(\n          sortableProps.onDragStart,\n          ({ active }) => setActiveId(active.id),\n        )}\n        onDragEnd={composeEventHandlers(sortableProps.onDragEnd, onDragEnd)}\n        onDragCancel={composeEventHandlers(sortableProps.onDragCancel, () =>\n          setActiveId(null),\n        )}\n        collisionDetection={collisionDetection ?? config.collisionDetection}\n        accessibility={{\n          ...props.accessibility,\n          announcements: {\n            onDragStart({ active }) {\n              return `Picked up sortable item ${active.id}. Use arrow keys to move, space to drop.`;\n            },\n            onDragOver({ active, over }) {\n              if (over) {\n                return `Sortable item ${active.id} was moved over position ${over.id}.`;\n              }\n              return `Sortable item ${active.id} is no longer over a droppable area.`;\n            },\n            onDragEnd({ active, over }) {\n              if (over) {\n                return `Sortable item ${active.id} was dropped over position ${over.id}.`;\n              }\n              return `Sortable item ${active.id} was dropped.`;\n            },\n            onDragCancel({ active }) {\n              return `Sorting was cancelled. Sortable item ${active.id} was dropped.`;\n            },\n            onDragMove({ active, over }) {\n              if (over) {\n                return `Sortable item ${active.id} was moved over position ${over.id}.`;\n              }\n              return `Sortable item ${active.id} is no longer over a droppable area.`;\n            },\n            ...props.accessibility?.announcements,\n          },\n        }}\n        {...sortableProps}\n      />\n    </SortableRootContext.Provider>\n  );\n}\n\nconst SortableContentContext = React.createContext<boolean>(false);\nSortableContentContext.displayName = CONTENT_NAME;\n\ninterface SortableContentProps extends SlotProps {\n  strategy?: SortableContextProps[\"strategy\"];\n  children: React.ReactNode;\n  asChild?: boolean;\n}\n\nconst SortableContent = React.forwardRef<HTMLDivElement, SortableContentProps>(\n  (props, forwardedRef) => {\n    const { strategy: strategyProp, asChild, ...contentProps } = props;\n    const context = useSortableContext(\"content\");\n\n    const ContentSlot = asChild ? Slot : \"div\";\n\n    const items = React.useMemo(() => {\n      return context.items.map((item) => context.getItemValue(item));\n    }, [context.items, context.getItemValue]);\n\n    return (\n      <SortableContentContext.Provider value={true}>\n        <SortableContext\n          items={items}\n          strategy={strategyProp ?? context.strategy}\n        >\n          <ContentSlot {...contentProps} ref={forwardedRef} />\n        </SortableContext>\n      </SortableContentContext.Provider>\n    );\n  },\n);\nSortableContent.displayName = CONTENT_NAME;\n\nconst SortableOverlayContext = React.createContext(false);\nSortableOverlayContext.displayName = OVERLAY_NAME;\n\nconst dropAnimation: DropAnimation = {\n  sideEffects: defaultDropAnimationSideEffects({\n    styles: {\n      active: {\n        opacity: \"0.4\",\n      },\n    },\n  }),\n};\n\ninterface SortableOverlayProps\n  extends Omit<React.ComponentPropsWithoutRef<typeof DragOverlay>, \"children\"> {\n  container?: HTMLElement | DocumentFragment | null;\n  children?:\n    | ((params: { value: UniqueIdentifier }) => React.ReactNode)\n    | React.ReactNode;\n}\n\nfunction SortableOverlay(props: SortableOverlayProps) {\n  const {\n    container: containerProp,\n    dropAnimation: dropAnimationProp,\n    children,\n    ...overlayProps\n  } = props;\n  const context = useSortableContext(\"overlay\");\n\n  const [mounted, setMounted] = React.useState(false);\n  React.useLayoutEffect(() => setMounted(true), []);\n\n  const container =\n    containerProp ?? (mounted ? globalThis.document?.body : null);\n\n  if (!container) return null;\n\n  return ReactDOM.createPortal(\n    <DragOverlay\n      modifiers={context.modifiers}\n      dropAnimation={dropAnimationProp ?? dropAnimation}\n      className={cn(!context.flatCursor && \"cursor-grabbing\")}\n      {...overlayProps}\n    >\n      <SortableOverlayContext.Provider value={true}>\n        {context.activeId ? (\n          typeof children === \"function\" ? (\n            children({ value: context.activeId })\n          ) : (\n            <SortableItem value={context.activeId} asChild>\n              {children}\n            </SortableItem>\n          )\n        ) : null}\n      </SortableOverlayContext.Provider>\n    </DragOverlay>,\n    container,\n  );\n}\n\ninterface SortableItemContextValue {\n  id: string;\n  attributes: React.HTMLAttributes<HTMLElement>;\n  listeners: DraggableSyntheticListeners | undefined;\n  setActivatorNodeRef: (node: HTMLElement | null) => void;\n  isDragging?: boolean;\n  disabled?: boolean;\n}\n\nconst SortableItemContext = React.createContext<SortableItemContextValue>({\n  id: \"\",\n  attributes: {},\n  listeners: undefined,\n  setActivatorNodeRef: () => {},\n  isDragging: false,\n});\nSortableItemContext.displayName = ITEM_NAME;\n\ninterface SortableItemProps extends SlotProps {\n  value: UniqueIdentifier;\n  asHandle?: boolean;\n  asChild?: boolean;\n  disabled?: boolean;\n}\n\nconst SortableItem = React.forwardRef<HTMLDivElement, SortableItemProps>(\n  (props, forwardedRef) => {\n    const {\n      value,\n      style,\n      asHandle,\n      asChild,\n      disabled,\n      className,\n      ...itemProps\n    } = props;\n\n    const inSortableContent = React.useContext(SortableContentContext);\n    const inSortableOverlay = React.useContext(SortableOverlayContext);\n\n    if (!inSortableContent && !inSortableOverlay) {\n      throw new Error(SORTABLE_ERROR.item);\n    }\n\n    const context = useSortableContext(\"item\");\n    const id = React.useId();\n    const {\n      attributes,\n      listeners,\n      setNodeRef,\n      setActivatorNodeRef,\n      transform,\n      transition,\n      isDragging,\n    } = useSortable({ id: value, disabled });\n\n    const composedRef = useComposedRefs(forwardedRef, (node) => {\n      if (disabled) return;\n      setNodeRef(node);\n      if (asHandle) setActivatorNodeRef(node);\n    });\n\n    const composedStyle = React.useMemo<React.CSSProperties>(() => {\n      return {\n        opacity: isDragging || disabled ? 0.5 : 1,\n        transform: CSS.Translate.toString(transform),\n        transition,\n        ...style,\n      };\n    }, [transform, transition, style, isDragging, disabled]);\n\n    const ItemSlot = asChild ? Slot : \"div\";\n\n    const itemContext = React.useMemo<SortableItemContextValue>(\n      () => ({\n        id,\n        attributes,\n        listeners,\n        setActivatorNodeRef,\n        isDragging,\n        disabled,\n      }),\n      [id, attributes, listeners, setActivatorNodeRef, isDragging, disabled],\n    );\n\n    if (value === \"\") {\n      throw new Error(`${ITEM_NAME} value cannot be an empty string.`);\n    }\n\n    return (\n      <SortableItemContext.Provider value={itemContext}>\n        <ItemSlot\n          id={id}\n          data-dragging={isDragging ? \"\" : undefined}\n          {...itemProps}\n          {...(asHandle ? attributes : {})}\n          {...(asHandle ? listeners : {})}\n          ref={composedRef}\n          style={composedStyle}\n          className={cn(\n            \"data-[dragging]:focus-visible:outline-none data-[dragging]:focus-visible:ring-1 data-[dragging]:focus-visible:ring-ring data-[dragging]:focus-visible:ring-offset-1\",\n            {\n              \"touch-none select-none\": asHandle,\n              \"cursor-default\": context.flatCursor,\n              \"data-[dragging]:cursor-grabbing\": !context.flatCursor,\n              \"cursor-grab\": !isDragging && asHandle && !context.flatCursor,\n              \"pointer-events-none\": disabled,\n            },\n            className,\n          )}\n        />\n      </SortableItemContext.Provider>\n    );\n  },\n);\nSortableItem.displayName = ITEM_NAME;\n\ninterface SortableItemHandleProps\n  extends React.ComponentPropsWithoutRef<\"button\"> {\n  asChild?: boolean;\n}\n\nconst SortableItemHandle = React.forwardRef<\n  HTMLButtonElement,\n  SortableItemHandleProps\n>((props, forwardedRef) => {\n  const { asChild, disabled, className, ...dragHandleProps } = props;\n  const itemContext = React.useContext(SortableItemContext);\n  if (!itemContext) {\n    throw new Error(SORTABLE_ERROR.itemHandle);\n  }\n  const context = useSortableContext(\"itemHandle\");\n\n  const isDisabled = disabled ?? itemContext.disabled;\n\n  const composedRef = useComposedRefs(forwardedRef, (node) => {\n    if (!isDisabled) return;\n    itemContext.setActivatorNodeRef(node);\n  });\n\n  const HandleSlot = asChild ? Slot : \"button\";\n\n  return (\n    <HandleSlot\n      aria-controls={itemContext.id}\n      data-dragging={itemContext.isDragging ? \"\" : undefined}\n      {...dragHandleProps}\n      {...itemContext.attributes}\n      {...itemContext.listeners}\n      ref={composedRef}\n      className={cn(\n        \"select-none disabled:pointer-events-none disabled:opacity-50\",\n        context.flatCursor\n          ? \"cursor-default\"\n          : \"cursor-grab data-[dragging]:cursor-grabbing\",\n        className,\n      )}\n      disabled={isDisabled}\n    />\n  );\n});\nSortableItemHandle.displayName = ITEM_HANDLE_NAME;\n\nconst Root = Sortable;\nconst Content = SortableContent;\nconst Item = SortableItem;\nconst ItemHandle = SortableItemHandle;\nconst Overlay = SortableOverlay;\n\nexport {\n  Content,\n  Item,\n  ItemHandle,\n  Overlay,\n  Root,\n  //\n  Sortable,\n  SortableContent,\n  SortableItem,\n  SortableItemHandle,\n  SortableOverlay,\n};\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}