{
  "name": "sortable",
  "type": "registry:ui",
  "dependencies": [
    "@dnd-kit/core",
    "@dnd-kit/modifiers",
    "@dnd-kit/sortable",
    "@dnd-kit/utilities",
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/sortable.tsx",
      "content": "\"use client\";\r\n\r\nimport {\r\n  DndContext,\r\n  type DndContextProps,\r\n  type DragEndEvent,\r\n  DragOverlay,\r\n  type DraggableSyntheticListeners,\r\n  type DropAnimation,\r\n  KeyboardSensor,\r\n  MouseSensor,\r\n  TouchSensor,\r\n  type UniqueIdentifier,\r\n  closestCenter,\r\n  closestCorners,\r\n  defaultDropAnimationSideEffects,\r\n  useSensor,\r\n  useSensors,\r\n} from \"@dnd-kit/core\";\r\nimport {\r\n  restrictToHorizontalAxis,\r\n  restrictToParentElement,\r\n  restrictToVerticalAxis,\r\n} from \"@dnd-kit/modifiers\";\r\nimport {\r\n  SortableContext,\r\n  type SortableContextProps,\r\n  arrayMove,\r\n  horizontalListSortingStrategy,\r\n  sortableKeyboardCoordinates,\r\n  useSortable,\r\n  verticalListSortingStrategy,\r\n} from \"@dnd-kit/sortable\";\r\nimport { CSS } from \"@dnd-kit/utilities\";\r\nimport { Slot, type SlotProps } from \"@radix-ui/react-slot\";\r\nimport * as React from \"react\";\r\n\r\nimport { composeEventHandlers, composeRefs } from \"@/lib/composition\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst orientationConfig = {\r\n  vertical: {\r\n    modifiers: [restrictToVerticalAxis, restrictToParentElement],\r\n    strategy: verticalListSortingStrategy,\r\n    collisionDetection: closestCenter,\r\n  },\r\n  horizontal: {\r\n    modifiers: [restrictToHorizontalAxis, restrictToParentElement],\r\n    strategy: horizontalListSortingStrategy,\r\n    collisionDetection: closestCenter,\r\n  },\r\n  both: {\r\n    modifiers: [restrictToParentElement],\r\n    strategy: undefined,\r\n    collisionDetection: closestCorners,\r\n  },\r\n};\r\n\r\nconst SORTABLE_NAME = \"Sortable\";\r\nconst SORTABLE_CONTENT_NAME = \"SortableContent\";\r\nconst SORTABLE_ITEM_NAME = \"SortableItem\";\r\nconst SORTABLE_ITEM_GRIP_NAME = \"SortableItemGrip\";\r\nconst SORTABLE_OVERLAY_NAME = \"SortableOverlay\";\r\n\r\nconst SORTABLE_ERROR = {\r\n  root: `${SORTABLE_NAME} components must be within ${SORTABLE_NAME}`,\r\n  content: `${SORTABLE_CONTENT_NAME} must be within ${SORTABLE_NAME}`,\r\n  item: `${SORTABLE_ITEM_NAME} must be within ${SORTABLE_CONTENT_NAME}`,\r\n  grip: `${SORTABLE_ITEM_GRIP_NAME} must be within ${SORTABLE_ITEM_NAME}`,\r\n  overlay: `${SORTABLE_OVERLAY_NAME} must be within ${SORTABLE_NAME}`,\r\n} as const;\r\n\r\ninterface UniqueItem {\r\n  id: UniqueIdentifier;\r\n}\r\n\r\ninterface SortableProviderContextValue<T extends UniqueItem> {\r\n  id: string;\r\n  items: T[];\r\n  modifiers: DndContextProps[\"modifiers\"];\r\n  strategy: SortableContextProps[\"strategy\"];\r\n  activeId: UniqueIdentifier | null;\r\n  setActiveId: (id: UniqueIdentifier | null) => void;\r\n  flatCursor: boolean;\r\n}\r\n\r\nconst SortableRoot = React.createContext<SortableProviderContextValue<{\r\n  id: UniqueIdentifier;\r\n}> | null>(null);\r\nSortableRoot.displayName = SORTABLE_NAME;\r\n\r\nfunction useSortableRoot() {\r\n  const context = React.useContext(SortableRoot);\r\n  if (!context) {\r\n    throw new Error(SORTABLE_ERROR.root);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface SortableProps<T extends UniqueItem> extends DndContextProps {\r\n  value: T[];\r\n  onValueChange?: (items: T[]) => void;\r\n  onMove?: (event: DragEndEvent) => void;\r\n  collisionDetection?: DndContextProps[\"collisionDetection\"];\r\n  modifiers?: DndContextProps[\"modifiers\"];\r\n  sensors?: DndContextProps[\"sensors\"];\r\n  orientation?: \"vertical\" | \"horizontal\" | \"both\";\r\n  flatCursor?: boolean;\r\n}\r\n\r\nfunction Sortable<T extends UniqueItem>(props: SortableProps<T>) {\r\n  const {\r\n    value,\r\n    onValueChange,\r\n    collisionDetection,\r\n    modifiers,\r\n    sensors: sensorsProp,\r\n    onMove,\r\n    orientation = \"vertical\",\r\n    flatCursor = false,\r\n    ...sortableProps\r\n  } = props;\r\n  const id = React.useId();\r\n  const [activeId, setActiveId] = React.useState<UniqueIdentifier | null>(null);\r\n  const sensors = useSensors(\r\n    useSensor(MouseSensor),\r\n    useSensor(TouchSensor),\r\n    useSensor(KeyboardSensor, {\r\n      coordinateGetter: sortableKeyboardCoordinates,\r\n    }),\r\n  );\r\n  const config = React.useMemo(\r\n    () => orientationConfig[orientation],\r\n    [orientation],\r\n  );\r\n  const contextValue = React.useMemo(\r\n    () => ({\r\n      id,\r\n      items: value,\r\n      modifiers: modifiers ?? config.modifiers,\r\n      strategy: config.strategy,\r\n      activeId,\r\n      setActiveId,\r\n      flatCursor,\r\n    }),\r\n    [\r\n      id,\r\n      value,\r\n      modifiers,\r\n      config.modifiers,\r\n      config.strategy,\r\n      activeId,\r\n      flatCursor,\r\n    ],\r\n  );\r\n\r\n  return (\r\n    <SortableRoot.Provider value={contextValue}>\r\n      <DndContext\r\n        id={id}\r\n        modifiers={modifiers ?? config.modifiers}\r\n        sensors={sensorsProp ?? sensors}\r\n        onDragStart={composeEventHandlers(\r\n          sortableProps.onDragStart,\r\n          ({ active }) => setActiveId(active.id),\r\n        )}\r\n        onDragEnd={composeEventHandlers(\r\n          sortableProps.onDragEnd,\r\n          ({ active, over, activatorEvent, collisions, delta }) => {\r\n            if (over && active.id !== over?.id) {\r\n              const activeIndex = value.findIndex(\r\n                (item) => item.id === active.id,\r\n              );\r\n              const overIndex = value.findIndex((item) => item.id === over.id);\r\n\r\n              if (onMove) {\r\n                onMove({ active, over, activatorEvent, collisions, delta });\r\n              } else {\r\n                onValueChange?.(arrayMove(value, activeIndex, overIndex));\r\n              }\r\n            }\r\n            setActiveId(null);\r\n          },\r\n        )}\r\n        onDragCancel={composeEventHandlers(sortableProps.onDragCancel, () =>\r\n          setActiveId(null),\r\n        )}\r\n        collisionDetection={collisionDetection ?? config.collisionDetection}\r\n        accessibility={{\r\n          announcements: {\r\n            onDragStart({ active }) {\r\n              return `Picked up sortable item ${active.id}. Use arrow keys to move, space to drop.`;\r\n            },\r\n            onDragOver({ active, over }) {\r\n              if (over) {\r\n                return `Sortable item ${active.id} was moved over position ${over.id}`;\r\n              }\r\n              return `Sortable item ${active.id} is no longer over a droppable area`;\r\n            },\r\n            onDragEnd({ active, over }) {\r\n              if (over) {\r\n                return `Sortable item ${active.id} was dropped over position ${over.id}`;\r\n              }\r\n              return `Sortable item ${active.id} was dropped`;\r\n            },\r\n            onDragCancel({ active }) {\r\n              return `Sorting was cancelled. Sortable item ${active.id} was dropped.`;\r\n            },\r\n            onDragMove({ active, over }) {\r\n              if (over) {\r\n                return `Sortable item ${active.id} was moved over position ${over.id}`;\r\n              }\r\n              return `Sortable item ${active.id} is no longer over a droppable area`;\r\n            },\r\n          },\r\n          ...sortableProps.accessibility,\r\n        }}\r\n        {...sortableProps}\r\n      />\r\n    </SortableRoot.Provider>\r\n  );\r\n}\r\n\r\nconst SortableContentContext = React.createContext<boolean>(false);\r\nSortableContentContext.displayName = SORTABLE_CONTENT_NAME;\r\n\r\ninterface SortableContentProps extends SlotProps {\r\n  strategy?: SortableContextProps[\"strategy\"];\r\n  children: React.ReactNode;\r\n  asChild?: boolean;\r\n}\r\n\r\nconst SortableContent = React.forwardRef<HTMLDivElement, SortableContentProps>(\r\n  (props, ref) => {\r\n    const { strategy: strategyProp, asChild, ...contentProps } = props;\r\n    const context = React.useContext(SortableRoot);\r\n    if (!context) {\r\n      throw new Error(SORTABLE_ERROR.content);\r\n    }\r\n\r\n    const ContentSlot = asChild ? Slot : \"div\";\r\n\r\n    return (\r\n      <SortableContentContext.Provider value={true}>\r\n        <SortableContext\r\n          items={context.items}\r\n          strategy={strategyProp ?? context.strategy}\r\n        >\r\n          <ContentSlot {...contentProps} ref={ref} />\r\n        </SortableContext>\r\n      </SortableContentContext.Provider>\r\n    );\r\n  },\r\n);\r\nSortableContent.displayName = SORTABLE_CONTENT_NAME;\r\n\r\nconst SortableOverlayContext = React.createContext(false);\r\nSortableOverlayContext.displayName = SORTABLE_OVERLAY_NAME;\r\n\r\nconst dropAnimation: DropAnimation = {\r\n  sideEffects: defaultDropAnimationSideEffects({\r\n    styles: {\r\n      active: {\r\n        opacity: \"0.4\",\r\n      },\r\n    },\r\n  }),\r\n};\r\n\r\ninterface SortableOverlayProps\r\n  extends Omit<React.ComponentPropsWithoutRef<typeof DragOverlay>, \"children\"> {\r\n  children?:\r\n    | ((params: { value: UniqueIdentifier }) => React.ReactNode)\r\n    | React.ReactNode;\r\n}\r\n\r\nfunction SortableOverlay(props: SortableOverlayProps) {\r\n  const { dropAnimation: dropAnimationProp, children, ...overlayProps } = props;\r\n  const context = React.useContext(SortableRoot);\r\n  if (!context) {\r\n    throw new Error(SORTABLE_ERROR.overlay);\r\n  }\r\n\r\n  const activeItem = context.items.find((item) => item.id === context.activeId);\r\n\r\n  return (\r\n    <DragOverlay\r\n      modifiers={context.modifiers}\r\n      dropAnimation={dropAnimationProp ?? dropAnimation}\r\n      className={cn(!context.flatCursor && \"cursor-grabbing\")}\r\n      {...overlayProps}\r\n    >\r\n      <SortableOverlayContext.Provider value={true}>\r\n        {activeItem ? (\r\n          typeof children === \"function\" ? (\r\n            children({ value: activeItem.id })\r\n          ) : (\r\n            <SortableItem value={activeItem.id} asChild>\r\n              {children}\r\n            </SortableItem>\r\n          )\r\n        ) : null}\r\n      </SortableOverlayContext.Provider>\r\n    </DragOverlay>\r\n  );\r\n}\r\n\r\ninterface SortableItemContextValue {\r\n  id: string;\r\n  attributes: React.HTMLAttributes<HTMLElement>;\r\n  listeners: DraggableSyntheticListeners | undefined;\r\n  isDragging?: boolean;\r\n}\r\n\r\nconst SortableItemContext = React.createContext<SortableItemContextValue>({\r\n  id: \"\",\r\n  attributes: {},\r\n  listeners: undefined,\r\n  isDragging: false,\r\n});\r\nSortableItemContext.displayName = SORTABLE_ITEM_NAME;\r\n\r\ninterface SortableItemProps extends SlotProps {\r\n  value: UniqueIdentifier;\r\n  asGrip?: boolean;\r\n  asChild?: boolean;\r\n}\r\n\r\nconst SortableItem = React.forwardRef<HTMLDivElement, SortableItemProps>(\r\n  (props, ref) => {\r\n    const inSortableContent = React.useContext(SortableContentContext);\r\n    const inSortableOverlay = React.useContext(SortableOverlayContext);\r\n\r\n    if (!inSortableContent && !inSortableOverlay) {\r\n      throw new Error(SORTABLE_ERROR.item);\r\n    }\r\n\r\n    const {\r\n      value,\r\n      style: styleProp,\r\n      asGrip,\r\n      asChild,\r\n      className,\r\n      ...itemProps\r\n    } = props;\r\n    const context = useSortableRoot();\r\n    const id = React.useId();\r\n    const {\r\n      attributes,\r\n      listeners,\r\n      setNodeRef,\r\n      transform,\r\n      transition,\r\n      isDragging,\r\n    } = useSortable({ id: value });\r\n\r\n    const style: React.CSSProperties = {\r\n      opacity: isDragging ? 0.5 : 1,\r\n      transform: CSS.Translate.toString(transform),\r\n      transition,\r\n      ...styleProp,\r\n    };\r\n\r\n    const ItemSlot = asChild ? Slot : \"div\";\r\n\r\n    const itemContext = React.useMemo<SortableItemContextValue>(\r\n      () => ({\r\n        id,\r\n        attributes,\r\n        listeners,\r\n        isDragging,\r\n      }),\r\n      [id, attributes, listeners, isDragging],\r\n    );\r\n\r\n    return (\r\n      <SortableItemContext.Provider value={itemContext}>\r\n        <ItemSlot\r\n          id={id}\r\n          data-sortable-item=\"\"\r\n          data-dragging={isDragging ? \"\" : undefined}\r\n          className={cn(\r\n            {\r\n              \"touch-none select-none\": asGrip,\r\n              \"cursor-default\": context.flatCursor,\r\n              \"data-[dragging]:cursor-grabbing\": !context.flatCursor,\r\n              \"cursor-grab\": !isDragging && asGrip && !context.flatCursor,\r\n            },\r\n            className,\r\n          )}\r\n          style={style}\r\n          {...(asGrip ? attributes : {})}\r\n          {...(asGrip ? listeners : {})}\r\n          ref={composeRefs(ref, (node) => setNodeRef(node))}\r\n          {...itemProps}\r\n        />\r\n      </SortableItemContext.Provider>\r\n    );\r\n  },\r\n);\r\nSortableItem.displayName = SORTABLE_ITEM_NAME;\r\n\r\ninterface SortableItemGripProps\r\n  extends React.ComponentPropsWithoutRef<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst SortableItemGrip = React.forwardRef<\r\n  HTMLButtonElement,\r\n  SortableItemGripProps\r\n>((props, ref) => {\r\n  const itemContext = React.useContext(SortableItemContext);\r\n  if (!itemContext) {\r\n    throw new Error(SORTABLE_ERROR.grip);\r\n  }\r\n\r\n  const { asChild, className, ...dragHandleProps } = props;\r\n  const context = useSortableRoot();\r\n\r\n  const GripSlot = asChild ? Slot : \"button\";\r\n\r\n  return (\r\n    <GripSlot\r\n      aria-controls={itemContext.id}\r\n      data-dragging={itemContext.isDragging ? \"\" : undefined}\r\n      className={cn(\r\n        \"select-none\",\r\n        context.flatCursor\r\n          ? \"cursor-default\"\r\n          : \"cursor-grab data-[dragging]:cursor-grabbing\",\r\n        className,\r\n      )}\r\n      {...itemContext.attributes}\r\n      {...itemContext.listeners}\r\n      ref={ref}\r\n      {...dragHandleProps}\r\n    />\r\n  );\r\n});\r\nSortableItemGrip.displayName = \"SortableItemGrip\";\r\n\r\nconst Root = Sortable;\r\nconst Content = SortableContent;\r\nconst Item = SortableItem;\r\nconst ItemGrip = SortableItemGrip;\r\nconst Overlay = SortableOverlay;\r\n\r\nexport {\r\n  Sortable,\r\n  SortableContent,\r\n  SortableItem,\r\n  SortableItemGrip,\r\n  SortableOverlay,\r\n  //\r\n  Root,\r\n  Content,\r\n  Item,\r\n  ItemGrip,\r\n  Overlay,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}