{
  "name": "sortable",
  "type": "registry:ui",
  "dependencies": [
    "@dnd-kit/core",
    "@dnd-kit/modifiers",
    "@dnd-kit/sortable",
    "@dnd-kit/utilities"
  ],
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "path": "ui/sortable.tsx",
      "content": "\"use client\";\n\nimport {\n  DndContext,\n  type DndContextProps,\n  type DragEndEvent,\n  DragOverlay,\n  type DraggableSyntheticListeners,\n  type DropAnimation,\n  KeyboardSensor,\n  MouseSensor,\n  TouchSensor,\n  type UniqueIdentifier,\n  closestCenter,\n  closestCorners,\n  defaultDropAnimationSideEffects,\n  useSensor,\n  useSensors,\n} from \"@dnd-kit/core\";\nimport {\n  restrictToHorizontalAxis,\n  restrictToParentElement,\n  restrictToVerticalAxis,\n} from \"@dnd-kit/modifiers\";\nimport {\n  SortableContext,\n  type SortableContextProps,\n  arrayMove,\n  horizontalListSortingStrategy,\n  sortableKeyboardCoordinates,\n  useSortable,\n  verticalListSortingStrategy,\n} from \"@dnd-kit/sortable\";\nimport { CSS } from \"@dnd-kit/utilities\";\nimport { Slot, type SlotProps } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\n\nimport { Button, type ButtonProps } from \"@/components/ui/button\";\nimport { composeRefs } from \"@/lib/compose-refs\";\nimport { cn, composeEventHandlers } from \"@/lib/utils\";\n\nconst orientationConfig = {\n  vertical: {\n    modifiers: [restrictToVerticalAxis, restrictToParentElement],\n    strategy: verticalListSortingStrategy,\n    collisionDetection: closestCenter,\n  },\n  horizontal: {\n    modifiers: [restrictToHorizontalAxis, restrictToParentElement],\n    strategy: horizontalListSortingStrategy,\n    collisionDetection: closestCenter,\n  },\n  both: {\n    modifiers: [restrictToParentElement],\n    strategy: undefined,\n    collisionDetection: closestCorners,\n  },\n};\n\ntype UniqueItem = { id: UniqueIdentifier };\ninterface SortableProviderContext<T extends UniqueItem> {\n  id: string;\n  items: T[];\n  modifiers: DndContextProps[\"modifiers\"];\n  strategy: SortableContextProps[\"strategy\"];\n  activeId: UniqueIdentifier | null;\n  setActiveId: (id: UniqueIdentifier | null) => void;\n  disableGrabCursor: boolean;\n}\n\nconst SortableRoot = React.createContext<\n  SortableProviderContext<{ id: UniqueIdentifier }> | undefined\n>(undefined);\n\nfunction useSortableRoot() {\n  const context = React.useContext(SortableRoot);\n  if (!context) {\n    throw new Error(\"useSortableRoot must be used within a SortableProvider\");\n  }\n  return context;\n}\n\ninterface SortableProps<T extends UniqueItem> extends DndContextProps {\n  value: T[];\n  onValueChange?: (items: T[]) => void;\n  onMove?: (event: DragEndEvent) => void;\n  collisionDetection?: DndContextProps[\"collisionDetection\"];\n  modifiers?: DndContextProps[\"modifiers\"];\n  sensors?: DndContextProps[\"sensors\"];\n  orientation?: \"vertical\" | \"horizontal\" | \"both\";\n  disableGrabCursor?: boolean;\n}\n\nfunction Sortable<T extends UniqueItem>(props: SortableProps<T>) {\n  const id = React.useId();\n  const {\n    value,\n    onValueChange,\n    collisionDetection,\n    modifiers,\n    sensors: sensorsProp,\n    onMove,\n    orientation = \"vertical\",\n    disableGrabCursor = false,\n    ...sortableProps\n  } = props;\n  const [activeId, setActiveId] = React.useState<UniqueIdentifier | null>(null);\n  const sensors = useSensors(\n    useSensor(MouseSensor),\n    useSensor(TouchSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    }),\n  );\n  const config = React.useMemo(\n    () => orientationConfig[orientation],\n    [orientation],\n  );\n  const contextValue = React.useMemo(\n    () => ({\n      id,\n      items: value,\n      modifiers: modifiers ?? config.modifiers,\n      strategy: config.strategy,\n      activeId,\n      setActiveId,\n      disableGrabCursor,\n    }),\n    [\n      id,\n      value,\n      modifiers,\n      config.modifiers,\n      config.strategy,\n      activeId,\n      disableGrabCursor,\n    ],\n  );\n\n  return (\n    <SortableRoot.Provider value={contextValue}>\n      <DndContext\n        id={id}\n        modifiers={modifiers ?? config.modifiers}\n        sensors={sensorsProp ?? sensors}\n        onDragStart={composeEventHandlers(\n          sortableProps.onDragStart,\n          ({ active }) => setActiveId(active.id),\n        )}\n        onDragEnd={composeEventHandlers(\n          sortableProps.onDragEnd,\n          ({ active, over, activatorEvent, collisions, delta }) => {\n            if (over && active.id !== over?.id) {\n              const activeIndex = value.findIndex(\n                (item) => item.id === active.id,\n              );\n              const overIndex = value.findIndex((item) => item.id === over.id);\n\n              if (onMove) {\n                onMove({ active, over, activatorEvent, collisions, delta });\n              } else {\n                onValueChange?.(arrayMove(value, activeIndex, overIndex));\n              }\n            }\n            setActiveId(null);\n          },\n        )}\n        onDragCancel={composeEventHandlers(sortableProps.onDragCancel, () =>\n          setActiveId(null),\n        )}\n        collisionDetection={collisionDetection ?? config.collisionDetection}\n        accessibility={{\n          announcements: {\n            onDragStart({ active }) {\n              return `Picked up sortable item ${active.id}. Use arrow keys to move, space to drop.`;\n            },\n            onDragOver({ active, over }) {\n              if (over) {\n                return `Sortable item ${active.id} was moved over position ${over.id}`;\n              }\n              return `Sortable item ${active.id} is no longer over a droppable area`;\n            },\n            onDragEnd({ active, over }) {\n              if (over) {\n                return `Sortable item ${active.id} was dropped over position ${over.id}`;\n              }\n              return `Sortable item ${active.id} was dropped`;\n            },\n            onDragCancel({ active }) {\n              return `Sorting was cancelled. Sortable item ${active.id} was dropped.`;\n            },\n            onDragMove({ active, over }) {\n              if (over) {\n                return `Sortable item ${active.id} was moved over position ${over.id}`;\n              }\n              return `Sortable item ${active.id} is no longer over a droppable area`;\n            },\n          },\n          ...sortableProps.accessibility,\n        }}\n        {...sortableProps}\n      />\n    </SortableRoot.Provider>\n  );\n}\n\ninterface SortableContentProps {\n  strategy?: SortableContextProps[\"strategy\"];\n  children: React.ReactNode;\n}\n\nfunction SortableContent({\n  strategy: strategyProp,\n  children,\n}: SortableContentProps) {\n  const context = useSortableRoot();\n\n  return (\n    <SortableContext\n      items={context.items}\n      strategy={strategyProp ?? context.strategy}\n    >\n      {children}\n    </SortableContext>\n  );\n}\n\nconst dropAnimation: DropAnimation = {\n  sideEffects: defaultDropAnimationSideEffects({\n    styles: {\n      active: {\n        opacity: \"0.4\",\n      },\n    },\n  }),\n};\n\ninterface SortableOverlayProps\n  extends Omit<React.ComponentPropsWithoutRef<typeof DragOverlay>, \"children\"> {\n  children?:\n    | ((params: { value: UniqueIdentifier }) => React.ReactNode)\n    | React.ReactNode;\n}\n\nfunction SortableOverlay(props: SortableOverlayProps) {\n  const { dropAnimation: dropAnimationProp, children, ...overlayProps } = props;\n  const context = useSortableRoot();\n\n  return (\n    <DragOverlay\n      modifiers={context.modifiers}\n      dropAnimation={dropAnimationProp ?? dropAnimation}\n      className={cn(!context.disableGrabCursor && \"cursor-grabbing\")}\n      {...overlayProps}\n    >\n      {context.activeId ? (\n        typeof children === \"function\" ? (\n          children({ value: context.activeId })\n        ) : (\n          <SortableItem value={context.activeId} asChild>\n            {children}\n          </SortableItem>\n        )\n      ) : null}\n    </DragOverlay>\n  );\n}\n\ninterface SortableItemContextProps {\n  id: string;\n  attributes: React.HTMLAttributes<HTMLElement>;\n  listeners: DraggableSyntheticListeners | undefined;\n  isDragging?: boolean;\n}\n\nconst SortableItemContext = React.createContext<SortableItemContextProps>({\n  id: \"\",\n  attributes: {},\n  listeners: undefined,\n  isDragging: false,\n});\n\nfunction useSortableItem() {\n  const context = React.useContext(SortableItemContext);\n  if (!context) {\n    throw new Error(\"useSortableItem must be used within a SortableItem\");\n  }\n  return context;\n}\n\ninterface SortableItemProps extends SlotProps {\n  value: UniqueIdentifier;\n  asGrip?: boolean;\n  asChild?: boolean;\n}\n\nconst SortableItem = React.forwardRef<HTMLDivElement, SortableItemProps>(\n  (props, ref) => {\n    const {\n      value,\n      style: styleProp,\n      asGrip,\n      asChild,\n      className,\n      ...itemProps\n    } = props;\n    const context = useSortableRoot();\n    const id = React.useId();\n    const {\n      attributes,\n      listeners,\n      setNodeRef,\n      transform,\n      transition,\n      isDragging,\n    } = useSortable({ id: value });\n\n    const style: React.CSSProperties = {\n      opacity: isDragging ? 0.5 : 1,\n      transform: CSS.Translate.toString(transform),\n      transition,\n      ...styleProp,\n    };\n\n    const ItemSlot = asChild ? Slot : \"div\";\n\n    const itemContext = React.useMemo<SortableItemContextProps>(\n      () => ({\n        id,\n        attributes,\n        listeners,\n        isDragging,\n      }),\n      [id, attributes, listeners, isDragging],\n    );\n\n    return (\n      <SortableItemContext.Provider value={itemContext}>\n        <ItemSlot\n          id={id}\n          ref={composeRefs(ref, (node) => setNodeRef(node))}\n          data-sortable-item=\"\"\n          data-dragging={isDragging ? \"\" : undefined}\n          className={cn(\n            {\n              \"cursor-default\": context.disableGrabCursor,\n              \"data-[dragging]:cursor-grabbing\": !context.disableGrabCursor,\n              \"cursor-grab\":\n                !isDragging && asGrip && !context.disableGrabCursor,\n            },\n            className,\n          )}\n          style={style}\n          {...(asGrip ? attributes : {})}\n          {...(asGrip ? listeners : {})}\n          {...itemProps}\n        />\n      </SortableItemContext.Provider>\n    );\n  },\n);\nSortableItem.displayName = \"SortableItem\";\n\ninterface SortableItemGripProps extends ButtonProps {}\n\nconst SortableItemGrip = React.forwardRef<\n  HTMLButtonElement,\n  SortableItemGripProps\n>((props, ref) => {\n  const { className, ...dragHandleProps } = props;\n  const context = useSortableRoot();\n  const itemContext = useSortableItem();\n\n  return (\n    <Button\n      ref={ref}\n      aria-controls={itemContext.id}\n      data-dragging={itemContext.isDragging ? \"\" : undefined}\n      className={cn(\n        context.disableGrabCursor\n          ? \"cursor-default\"\n          : \"cursor-grab data-[dragging]:cursor-grabbing\",\n        className,\n      )}\n      {...itemContext.attributes}\n      {...itemContext.listeners}\n      {...dragHandleProps}\n    />\n  );\n});\nSortableItemGrip.displayName = \"SortableItemGrip\";\n\nexport {\n  Sortable,\n  SortableContent,\n  SortableItemGrip,\n  SortableItem,\n  SortableOverlay,\n};\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}